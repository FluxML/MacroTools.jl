var documenterSearchIndex = {"docs":
[{"location":"pattern-matching/#Pattern-Matching","page":"Pattern Matching","title":"Pattern Matching","text":"Pattern matching enables macro writers to deconstruct Julia expressions in a more declarative way, and without having to know in great detail how syntax is represented internally. For example, say you have a type definition:\n\nex = quote\n  struct Foo\n    x::Int\n    y\n  end\nend\n\nIf you know what you're doing, you can pull out the name and fields via:\n\njulia> if Meta.isexpr(ex.args[2], :struct)\n         (ex.args[2].args[2], ex.args[2].args[3].args)\n       end\n(:Foo, Any[:(#= line 3 =#), :(x::Int), :(#= line 4 =#), :y])\n\nBut this is hard to write – since you have to deconstruct the type expression by hand – and hard to read, since you can't tell at a glance what's being achieved. On top of that, there's a bunch of messy stuff to deal with like pesky begin blocks which wrap a single expression, line numbers, etc. etc.\n\nEnter MacroTools:\n\njulia> using MacroTools\n\njulia> @capture(ex, struct T_ fields__ end)\ntrue\n\njulia> T, fields\n(:Foo, Any[:(x::Int), :y])\n\nSymbols like T_ underscore are treated as catchalls which match any expression, and the expression they match is bound to the (underscore-less) variable, as above.\n\nBecause @capture doubles as a test as well as extracting values, you can easily handle unexpected input (try writing this by hand):\n\n@capture(ex, f_(xs__) where {T_} = body_) ||\n  error(\"expected a function with a single type parameter\")\n\nSymbols like f__ (double underscored) are similar, but slurp a sequence of arguments into an array. For example:\n\njulia> @capture(:[1, 2, 3, 4, 5, 6, 7], [1, a_, 3, b__, c_])\ntrue\n\njulia> a, b, c\n(2,[4,5,6],7)\n\nSlurps don't have to be at the end of an expression, but like the Highlander there can only be one (per expression).","category":"section"},{"location":"pattern-matching/#Matching-on-expression-type","page":"Pattern Matching","title":"Matching on expression type","text":"@capture can match expressions by their type, which is either the head of Expr objects or the typeof atomic stuff like Symbols and Ints. For example:\n\n@capture(ex, foo(x_String_string))\n\nThis will match a call to the foo function which has a single argument, which may either be a String object or a Expr(:string, ...) (e.g. @capture(:(foo(\"$(a)\")), foo(x_String_string))). Julia string literals may be parsed into either type of object, so this is a handy way to catch both.\n\nAnother common use case is to catch symbol literals, e.g.\n\n@capture(ex,\n  struct T_Symbol\n    fields__\n  end)\n\nwhich will match e.g. struct Foo ... but not struct Foo{V} ...\n\nIf you want to match on quoted symbols like :(:a) you might look at the AST Julia produces and expect to be able to use the type QuoteNode in your pattern. Hence,  you would expect the following to produce 1:\n\n@match :(:a) begin\n  s_QuoteNode => 1\n  s_quote => 2\nend\n\nHowever, it evaluates to 2 because MacroTools normalizes expressions before comparing  them to your pattern. And QuoteNode gets normalized to quote so to match a quoted  symbol you will need @capture(ex, s_quote) && s.args[1] isa Symbol","category":"section"},{"location":"pattern-matching/#Unions","page":"Pattern Matching","title":"Unions","text":"@capture can also try to match the expression against one pattern or another, for example:\n\n@capture(ex, (f_(args__) = body_) | (function f_(args__) body_ end))\n\nwill match both kinds of function syntax (though it's easier to use shortdef to normalise definitions). You can also do this within expressions, e.g.\n\n@capture(ex, (f_(args__) where {T_}) | (f_(args__)) = body_)\n\nmatches a function definition like func(a::T) where {T<:Number} = supertype(T), with a single type parameter bound to T if possible. If not, T = nothing.","category":"section"},{"location":"pattern-matching/#Expression-Walking","page":"Pattern Matching","title":"Expression Walking","text":"If you've ever written any more interesting macros, you've probably found yourself writing recursive functions to work with nested Expr trees. MacroTools' prewalk and postwalk functions factor out the recursion, making macro code much more concise and robust.\n\nThese expression-walking functions essentially provide a kind of find-and-replace for expression trees. For example:\n\njulia> using MacroTools: prewalk, postwalk\n\njulia> postwalk(x -> x isa Integer ? x + 1 : x, :(2+3))\n:(3 + 4)\n\nIn other words, look at each item in the tree; if it's an integer, add one, if not, leave it alone.\n\nWe can do more complex things if we combine this with @capture. For example, say we want to insert an extra argument into all function calls:\n\njulia> ex = quote\n         x = f(y, g(z))\n         return h(x)\n       end\n\njulia> postwalk(x -> @capture(x, f_(xs__)) ? :($f(5, $(xs...))) : x, ex)\nquote  # REPL[20], line 2:\n    x = f(5, y, g(5, z)) # REPL[20], line 3:\n    return h(5, x)\nend\n\nMost of the time, you can use postwalk without worrying about it, but we also provide prewalk. The difference is the order in which you see sub-expressions; postwalk sees the leaves of the Expr tree first and the whole expression last, while prewalk is the opposite.\n\njulia> postwalk(x -> @show(x) isa Integer ? x + 1 : x, :(2+3*4));\nx = :+\nx = 2\nx = :*\nx = 3\nx = 4\nx = :(4 * 5)\nx = :(3 + 4 * 5)\n\njulia> prewalk(x -> @show(x) isa Integer ? x + 1 : x, :(2+3*4));\nx = :(2 + 3 * 4)\nx = :+\nx = 2\nx = :(3 * 4)\nx = :*\nx = 3\nx = 4\n\nA significant difference is that prewalk will walk into whatever expression you return.\n\njulia> postwalk(x -> @show(x) isa Integer ? :(a+b) : x, 2)\nx = 2\n:(a + b)\n\njulia> prewalk(x -> @show(x) isa Integer ? :(a+b) : x, 2)\nx = 2\nx = :+\nx = :a\nx = :b\n:(a + b)\n\nThis makes it somewhat more prone to infinite loops; for example, if we returned :(1+b) instead of :(a+b), prewalk would hang trying to expand all of the 1s in the expression.\n\nWith these tools in hand, a useful general pattern for macros is:\n\nmacro foo(ex)\n  postwalk(ex) do x\n    @capture(x, some_pattern) || return x\n    return new_x\n  end\nend","category":"section"},{"location":"utilities/#Utilities","page":"Utilities","title":"Utilities","text":"","category":"section"},{"location":"utilities/#Function-definitions","page":"Utilities","title":"Function definitions","text":"Function definitions pose a problem to pattern matching, since there are a lot of different ways to define a function. For example, a pattern that captures f(x) = 2x will not match the following syntax:\n\nfunction f(x)\n  return 2x\nend\n\nThere are a couple of ways to handle this. One way is to use longdef or shortdef to normalise function definitions to short form, before matching it.\n\njulia> ex = :(function f(x) 2x end)\n:(function f(x)\n      #= none:1 =#\n      2x\n  end)\n\njulia> MacroTools.shortdef(ex)\n:(f(x) = begin\n          #= none:1 =#\n          2x\n      end)\n\nMore generally it's also possible to use splitdef and combinedef to handle the full range of function syntax.","category":"section"},{"location":"utilities/#Other-Utilities","page":"Utilities","title":"Other Utilities","text":"","category":"section"},{"location":"utilities/#MacroTools.splitdef","page":"Utilities","title":"MacroTools.splitdef","text":"splitdef(fdef)\n\nMatch any function definition\n\nfunction name{params}(args; kwargs)::rtype where {whereparams} # `params` is used in constructors\n   body\nend\n\nand return Dict(:name=>..., :args=>..., etc.). The definition can be rebuilt by calling MacroTools.combinedef(dict).\n\nSee also: combinedef\n\n\n\n\n\n","category":"function"},{"location":"utilities/#MacroTools.combinedef","page":"Utilities","title":"MacroTools.combinedef","text":"combinedef(dict::Dict)\n\ncombinedef is the inverse of splitdef. It takes a splitdef-like Dict and returns a function definition.\n\nThis function approximately does the following (but more sophisticated to avoid emitting parts that did not actually appear in the original function definition.)\n\nrtype = get(dict, :rtype, :Any)\nall_params = [get(dict, :params, [])..., get(dict, :whereparams, [])...]\n:(function $(dict[:name]){$(all_params...)}($(dict[:args]...);\n                                            $(dict[:kwargs]...))::$rtype\n      $(dict[:body])\n  end)\n\n\n\n\n\n","category":"function"},{"location":"utilities/#MacroTools.splitarg","page":"Utilities","title":"MacroTools.splitarg","text":"splitarg(arg)\n\nMatch function arguments (whether from a definition or a function call) such as x::Int=2 and return (arg_name, arg_type, is_splat, default). arg_name and default are nothing when they are absent. For example:\n\njulia> map(splitarg, (:(f(a=2, x::Int=nothing, y, args...))).args[2:end])\n4-element Array{Tuple{Symbol,Symbol,Bool,Any},1}:\n (:a, :Any, false, 2)\n (:x, :Int, false, :nothing)\n (:y, :Any, false, nothing)\n (:args, :Any, true, nothing)\n\nSee also: combinearg\n\n\n\n\n\n","category":"function"},{"location":"utilities/#MacroTools.combinearg","page":"Utilities","title":"MacroTools.combinearg","text":"combinearg(arg_name, arg_type, is_splat, default)\n\ncombinearg is the inverse of splitarg.\n\n\n\n\n\n","category":"function"},{"location":"utilities/#MacroTools.@q","page":"Utilities","title":"MacroTools.@q","text":"@q [expression]\n\nLike the quote keyword but doesn't insert line numbers from the construction site. e.g. compare @q begin end with quote end. Line numbers of interpolated expressions are preserverd.\n\nSee also: rmlines\n\n\n\n\n\n","category":"macro"},{"location":"utilities/#MacroTools.@qq","page":"Utilities","title":"MacroTools.@qq","text":"@qq [expression]\n\nLike the quote keyword but replace construction site line numbers with source. Line numbers of interpolated expressions are preserved. The result is that line numbers will be attributed to the macro usage site, instead of the macro source code.\n\nOnly works inside of a macro definition.\n\nSee also: @q\n\n\n\n\n\n","category":"macro"},{"location":"utilities/#MacroTools.isexpr","page":"Utilities","title":"MacroTools.isexpr","text":"isexpr(x, ts...)\n\nConvenient way to test the type of a Julia expression. Expression heads and types are supported, so for example you can call\n\nisexpr(expr, String, :string)\n\nto pick up on all string-like expressions.\n\n\n\n\n\n","category":"function"},{"location":"utilities/#MacroTools.rmlines","page":"Utilities","title":"MacroTools.rmlines","text":"rmlines(x)\n\nRemove the line nodes from a block or array of expressions.\n\nCompare quote end vs rmlines(quote end)\n\nExamples\n\nTo work with nested blocks:\n\nprewalk(rmlines, ex)\n\nSee also: @q\n\n\n\n\n\n","category":"function"},{"location":"utilities/#MacroTools.rmdocs","page":"Utilities","title":"MacroTools.rmdocs","text":"rmdocs(x)\n\nRemove the documentation macros from the expression.\n\nExamples\n\nTo work with nested blocks:\n\nprewalk(rmdocs, ex)\n\nSee also: rmlines\n\n\n\n\n\n","category":"function"},{"location":"utilities/#MacroTools.unblock","page":"Utilities","title":"MacroTools.unblock","text":"unblock(expr)\n\nRemove outer begin blocks from an expression, if the block is redundant (i.e. contains only a single expression).\n\n\n\n\n\n","category":"function"},{"location":"utilities/#MacroTools.namify","page":"Utilities","title":"MacroTools.namify","text":"An easy way to get the (function/type) name out of expressions like foo{T} or Bar{T} <: Vector{T}.\n\n\n\n\n\n","category":"function"},{"location":"utilities/#MacroTools.inexpr","page":"Utilities","title":"MacroTools.inexpr","text":"inexpr(expr, x)\n\nSimple expression match; will return true if the expression x can be found inside expr.\n\ninexpr(:(2+2), 2) == true\n\n\n\n\n\n","category":"function"},{"location":"utilities/#MacroTools.gensym_ids","page":"Utilities","title":"MacroTools.gensym_ids","text":"gensym_ids(expr)\n\nReplaces gensyms with unique ids (deterministically).\n\njulia> x, y = gensym(\"x\"), gensym(\"y\")\n(Symbol(\"##x#363\"), Symbol(\"##y#364\"))\n\njulia> MacroTools.gensym_ids(:($x+$y))\n:(x_1 + y_2)\n\n\n\n\n\n","category":"function"},{"location":"utilities/#MacroTools.alias_gensyms","page":"Utilities","title":"MacroTools.alias_gensyms","text":"alias_gensyms(expr)\n\nReplaces gensyms with animal names. This makes gensym'd code far easier to follow.\n\njulia> x, y = gensym(\"x\"), gensym(\"y\")\n(Symbol(\"##x#363\"), Symbol(\"##y#364\"))\n\njulia> MacroTools.alias_gensyms(:($x+$y))\n:(porcupine + gull)\n\n\n\n\n\n","category":"function"},{"location":"utilities/#MacroTools.@expand","page":"Utilities","title":"MacroTools.@expand","text":"More convenient macro expansion, e.g.\n\n@expand @time foo()\n\n\n\n\n\n","category":"macro"},{"location":"utilities/#MacroTools.isdef","page":"Utilities","title":"MacroTools.isdef","text":"Test for function definition expressions. function f end and anonymous functions are considered as function definitions and return true.\n\n\n\n\n\n","category":"function"},{"location":"utilities/#MacroTools.flatten","page":"Utilities","title":"MacroTools.flatten","text":"flatten(ex)\n\nFlatten any redundant blocks into a single block, over the whole expression.\n\n\n\n\n\n","category":"function"},{"location":"utilities/#MacroTools.prettify","page":"Utilities","title":"MacroTools.prettify","text":"prettify(ex)\n\nMakes generated code generaly nicer to look at.\n\nKeywords\n\nlines::Bool=false: whether to preserve line number nodes\nalias::Bool=true: whether to replace gensyms with animal names\ndocs::Bool=false: whether to preserve docstrings\n\n\n\n\n\n","category":"function"},{"location":"#MacroTools.jl","page":"Home","title":"MacroTools.jl","text":"MacroTools provides a library of tools for working with Julia code and expressions. This includes a powerful template-matching system and code-walking tools that let you do deep transformations of code in a few lines.","category":"section"}]
}
